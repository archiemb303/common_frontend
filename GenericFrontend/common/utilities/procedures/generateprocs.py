"""Module to create stored procedures in db as well as autogenerated files with stored procdure names
with its definitions."""
import logging
import os
import re
import django
django.setup()
from argparse import ArgumentDefaultsHelpFormatter, ArgumentParser
from genericfrontend.sp_manage import get_filecontent
from common.utilities.procedures.importfile_procdefinitionvariables import *
from common.utilities.procedures.procdefinitionvariables.procdefinitionvariables_getallproc_query import *
from common.utilities.lib import sql_execute_query, get_all_procs_query

# Get an instance of a logger
logger = logging.getLogger("genericfrontend_1.0")


def proc_file_generate(filename, output_path):
    """Module to create stored procedures in db as well as autogenerated files with stored procdure names."""
    existing_procnames_list, new_procnames_list, procnames_collection, output_json, dict1 = [], [], [], {}, {}
    try:
        # Check for mismatch between stored procedures stored as text in python code base and database
        # and delete the mismatched stored procedure files from python code base.
        check_diff = compare_filelist_dbproclist(output_path)
        match = re.findall(r"'Status': 'Failure'", str(check_diff))
        if match:
            return check_diff
        # Fetch the contents of file having procedure definitions stored as strings in variable.
        fileread = get_filecontent(str(filename))
        match1 = re.findall(r"'Status': 'Failure'", str(fileread))
        if match1:
            return fileread
        if len(fileread) == 0:
            match = re.findall(r'genericfrontend\\(.*)\/utilities/procedures/procdefinitionvariables/'
                               r'(procdefinitionvariables_collection.py)', filename)
            output_json = dict(zip(['Status', 'Message', 'Payload'],
                                   ['Success', f'{match[0][1]} File is empty in {match[0][0]}', match[0][0]]))
            return output_json
        for line in fileread:
            input_string = re.findall(r'(.*)\s+=.*"""', line)
            if input_string:
                input_string_var = input_string[0]
            # Fetch the stored procedure name.
            procnamelist = re.findall(
                r'CREATE OR REPLACE FUNCTION public\.(.*)\(.*', line)
            if procnamelist:
                procnames_collection.append(procnamelist[0])
            if procnamelist:
                if procnamelist[0] not in os.listdir(output_path):
                    procdef = f'{input_string_var}'
                    # Create the stored procedure in database.
                    sp_create = create_proc(procdef)
                    match2 = re.findall(r"'Status': 'Failure'", str(sp_create))
                    if match2:
                        return sp_create
                    sp = f'{procnamelist[0]}'
                    # Create autogenerated files with stored procedure names.
                    sp_filenames = create_procdef_files(
                        sp, input_string_var, output_path)
                    match3 = re.findall(
                        r"'Status': 'Failure'", str(sp_filenames))
                    if match3:
                        return sp_filenames
                    new_procnames_list.append(sp)
                else:
                    existing_procnames_list.append(procnamelist[0])
        # Check for duplicates, if another stored procedure with same name already exists.
        procnames_check_count = check_procnames_count(procnames_collection)
        match3 = re.findall(r"'Status': 'Failure'", str(procnames_check_count))
        if match3:
            return procnames_check_count
        if len(new_procnames_list) > 0:
            newprocnames_details = dict(zip(['Status', 'Message', 'Payload'],
                                   ['Success', f'{new_procnames_list} procedures are created in {filename}', new_procnames_list]))
            return newprocnames_details, procnames_check_count
        if len(existing_procnames_list) > 0:
            existingprocnames_details = dict(zip(['Status', 'Message', 'Payload'],
                                                 ['Success', 'No new procedures created', existing_procnames_list]))
            return existingprocnames_details, procnames_check_count

    except Exception as ex:
        output_json = dict(zip(['Status', 'Message', 'Payload'], ['Failure',
                                                                  f"Issues happened while creating procedures "
                                                                  f"and procedure files. Encountered Exception: {ex}",
                                                                  None]))
        return output_json


def create_proc(arg):
    """Function for creating stored procedure."""
    input_json, output_json, payload = arg, {}, {'Payload': None}
    try:
        sql = sql_execute_query(eval(input_json))
        return sql
    except Exception as ex:
        output_json = dict(zip(['Status', 'Message', 'Payload'], ['Failure',
                                                                  f"Issues happened while creating stored procedure."
                                                                  f" Encountered Exception"
                                                                  f": {ex}", payload['Payload']]))
        return output_json


def create_procdef_files(sp, arg, output_path):
    """Function for creating stored procedure files with sp names."""
    try:
        sp_path = os.path.abspath(output_path) + '/' + sp
        with open(sp_path, 'w') as f:
            f.write(eval(f'{arg}'))
    except Exception as ex:
        output_json = dict(zip(['Message', 'Payload'], [f'Encountered exception in creating procedure files with '
                                                        f'definitions   : {ex}', None]))
        return output_json


def check_procnames_count(list1):
    """Check for duplicates, if another stored procedure with same name already exists."""
    dict1, list2 = {}, []
    try:
        flag = 0
        for proc_name in list1:
            if proc_name not in dict1:
                dict1[proc_name] = 1
                output_json = dict(
                    zip(['Message', 'Payload'], ['No duplicates', None]))
            else:
                dict1[proc_name] += 1
                flag = 1
        if flag:
            for key, value in dict1.items():
                if dict1[key] > 1:
                    list2.append(key)
            output_json = dict(zip(['Message', 'Payload'], [
                               f'{list2} are duplicates', list2]))
            return output_json
        return output_json

    except Exception as ex:
        output_json = dict(zip(['Message', 'Payload'], [
                           f'Encountered excetion in fetching proc names : {ex}', None]))
        return output_json


def get_all_pythonprocfiles(arg):
    """Function for fetching stored procedures stored in text format in python code base ."""
    input_json, output_json, payload, filelist = arg, {}, {'Payload': None}, []
    try:
        files = os.listdir(arg)
        if len(files) > 0:
            for file in files:
                if file.startswith('sp'):
                    filelist.append(file)
            return filelist
        else:
            return
    except Exception as ex:
        output_json = dict(zip(['Status', 'Message', 'Payload'], ['Failure',
                                                                  f"Issues happened while fetching stored procedures "
                                                                  f"stored in text format in python code base."
                                                                  f" Encountered Exception"
                                                                  f": {ex}", payload['Payload']]))
        return output_json


def get_all_dbproc(arg):
    """Function for fetching all stored procedures from database."""
    input_json, output_json, payload = arg, {}, {'Payload': None}
    try:
        sql = get_all_procs_query(input_json)
        return sql
    except Exception as ex:
        output_json = dict(zip(['Status', 'Message', 'Payload'], ['Failure',
                                                                  f"Issues happened while fetching "
                                                                  f"all stored procedures from database."
                                                                  f" Encountered Exception"
                                                                  f": {ex}", payload['Payload']]))
        return output_json


def compare_filelist_dbproclist(output_path):
    """Function for comparing the diff between stored procedures stored as text in python code base and database."""
    output_json, payload = {}, {'Payload': None}
    try:
        python_procfiles = get_all_pythonprocfiles(output_path)
        match = re.findall(r"'Status': 'Failure'", str(python_procfiles))
        if match:
            return python_procfiles
        if python_procfiles is None:
            return
        db_procfiles = get_all_dbproc(sp_var_getall_procs)
        match1 = re.findall(r"'Status': 'Failure'", str(python_procfiles))
        if match1:
            return db_procfiles
        diff_files = [i for i in python_procfiles if i not in db_procfiles]
        if len(diff_files) == 0:
            return

        for file in diff_files:
            os.remove(output_path + '/' + file)
            if len(diff_files) == 0:
                return
    except Exception as ex:
        output_json = dict(zip(['Status', 'Message', 'Payload'], ['Failure',
                                                                  f"Issues happened while comparing the diff between"
                                                                  f" stored procedures in python file and database."
                                                                  f" Encountered Exception"
                                                                  f": {ex}", payload['Payload']]))
        return output_json


if __name__ == '__main__':
    parser = ArgumentParser(description="Build Package", formatter_class=ArgumentDefaultsHelpFormatter)
    parser.add_argument("--filename", required=True, help="set flag for filename")
    parser.add_argument("--output_path", required=True, help="set flag for output_path")
    args = parser.parse_args()
    print(proc_file_generate(args.filename, args.output_path))


